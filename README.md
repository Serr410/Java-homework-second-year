# Список лабораторных работ 
Основной код, а также файлы содержащие все текущие лабораторные работы за 2025. В течении семестра тут будут появляться дополнительные файлы, в соответствии с датами выполнения/исправления работ по курсу "Язык программирования Java".

## Содержание
- [О проекте](#о-проекте)
- [Установка](#установка)
- [Использование](#использование)
- [_Задачи лабораторной работы 1_](#Задачи-лабораторной-работы-1)
- [_Задачи лабораторной работы 2_](#Задачи-лабораторной-работы-2)
- [_Задачи лабораторной работы 3_](#Задачи-лабораторной-работы-3)
- [_Задачи лабораторной работы 4_](#Задачи-лабораторной-работы-4)
- [_Задачи лабораторной работы 5_](#Задачи-лабораторной-работы-5)
- [_Задачи лабораторной работы 6_](#Задачи-лабораторной-работы-6)
- [Тесты](#Тесты)
- [To Do](#to-do)
- [Команда проекта](#команда-проекта)

## О проекте
* Использованный язык: Java
* Тема: изучение языка Java в рамках курса университета

## Установка
Программа создавалась для использования с компилятором IntelliJ IDEA Community Edition.
Файлы вставить в существующий проект в папку ...\src после чего запустить код в компиляторе.
* _В будующем метод установки может, и скорее всего, изменится._


## Использование
После запуска программы будет предложен выбора лабораторной работы в консоли, после чего представлен ряд задач в исходном порядке. В процессе могут быть востребованны дополнительные данные, просьба о вводе которых отобразиться в консоли.
### Задачи лабораторной работы 1:
* ### Дробная часть
  
Дана сигнатура метода: public double fraction (double x);
Необходимо реализовать метод таким образом, чтобы он возвращал только дробную часть числа х. П
* ### Букву в число
  
Дана сигнатура метода: public int charToNum (char x);
Метод принимает символ х, который представляет собой один из “0 1 2 3 4 5 6 7
8 9”. Необходимо реализовать метод таким образом, чтобы он преобразовывал
символ в соответствующее число.
* ### Двузначное
  
Дана сигнатура метода: public bool is2Digits (int x);
Необходимо реализовать метод таким образом, чтобы он принимал число x и
возвращал true, если оно двузначное.
* ### Диапазон
  
Дана сигнатура метода: public bool isInRange (int a, int b, int num);
Метод принимает левую и правую границу (a и b) некоторого числового
диапазона. Необходимо реализовать метод таким образом, чтобы он возвращал
true, если num входит в указанный диапазон (включая границы). Обратите
внимание, что отношение a и b заранее неизвестно (неясно кто из них больше, а
кто меньше)
* ### Равенство
  
Дана сигнатура метода: public bool isEqual(int a, int b, int c);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
все три полученных методом числа равны.
* ### Модуль числа
  
Дана сигнатура метода: public int abs (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал модуль
числа х (если оно было положительным, то таким и остается, если он было
отрицательным – то необходимо вернуть его без знака минус).
* ### Тридцать пять
  
Дана сигнатура метода: public bool is35 (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
число x делится нацело на 3 или 5. При этом, если оно делится и на 3, и на 5, то
вернуть надо false. Подсказка: оператор % позволяет получить остаток от
деления.
* ### Тройной максимум
  
Дана сигнатура метода: public int max3 (int x, int y, int z);
Необходимо реализовать метод таким образом, чтобы он возвращал
максимальное из трех полученных методом чисел.
* ### Двойная сумма
  
Дана сигнатура метода: public int sum2 (int x, int y);
Необходимо реализовать метод таким образом, чтобы он возвращал сумму
чисел x и y. Однако, если сумма попадает в диапазон от 10 до 19, то надо вернуть
число 20.
* ### День недели
  
Дана сигнатура метода: public String day (int x);
Метод принимает число x, обозначающее день недели. Необходимо реализовать
метод таким образом, чтобы он возвращал строку, которая будет обозначать
текущий день недели, где 1- это понедельник, а 7 – воскресенье. Если число не
от 1 до 7 то верните текст “это не день недели”. Вместо if в данной задаче
используйте switch.
* ### Числа подряд
  
Дана сигнатура метода: public String listNums (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой будут записаны все числа от 0 до x (включительно).
* ### Четные числа
  
Дана сигнатура метода: public String chet (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой будут записаны все четные числа от 0 до x (включительно).
* ### Длина числа
  
Дана сигнатура метода: public int numLen (long x);
Необходимо реализовать метод таким образом, чтобы он возвращал количество
знаков в числе x.
* ### Квадрат
  
Дана сигнатура метода: public void square (int x);
Необходимо реализовать метод таким образом, чтобы он выводил на экран
квадрат из символов ‘*’ размером х, у которого х символов в ряд и х символов в
высоту.
* ### Правый треугольник
  
Дана сигнатура метода: public void rightTriangle (int x);
Необходимо реализовать метод таким образом, чтобы он выводил на экран
треугольник из символов ‘*’ у которого х символов в высоту, а количество
символов в ряду совпадает с номером строки, при этом треугольник выровнен
по правому краю.
* ### Поиск первого значения
  
Дана сигнатура метода: public int findFirst (int[] arr, int x);
Необходимо реализовать метод таким образом, чтобы он возвращал индекс
первого вхождения числа x в массив arr. Если число не входит в массив –
возвращается -1.
* ### Поиск максимального
  
Дана сигнатура метода: public int maxAbs (int[] arr);
Необходимо реализовать метод таким образом, чтобы он возвращал
наибольшее по модулю (то есть без учета знака) значение массива arr.
* ### Добавление массива в массив
  
Дана сигнатура метода: public int[] add (int[] arr, int[] ins, int pos);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, который будет содержать все элементы массива arr, однако в позицию
pos будут вставлены значения массива ins.
* ### Возвратный реверс
  
Дана сигнатура метода: public int[] reverseBack (int[] arr);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором значения массива arr записаны задом наперед.
* ### Все вхождения
  
Дана сигнатура метода: public int[] findAll (int[] arr, int x);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором записаны индексы всех вхождений числа x в массив arr.

### Задачи лабораторной работы 2:
* ### Имена
  
Создайте сущность Имя, которая описывается тремя параметрами: Фамилия, Личное имя, 
Отчество. Имя может быть приведено к строковому виду, включающему традиционное 
представление всех трех параметров: Фамилия Имя Отчество (например “Иванов Иван 
Иванович”). Необходимо предусмотреть возможность того, что какой-либо из параметров может 
быть не задан, и в этом случае он не учитывается при приведении к текстовому виду. 
Необходимо создать следующие имена: 
* Клеопатра 
* Пушкин Александр Сергеевич 
* Маяковский Владимир

Обратите внимание, что при выводе на экран, не заданные параметры никак не участвуют в 
образовании строки. 
* ### Человек с именем

Объедините сущности Человек из задачи 1.2 и Имя из задачи 1.3 таким образом, чтобы имя 
человека задавалось с использованием сущности 1.3, а не строки.  
Необходимо объединить ранее созданные объекты имен и людей, с получением: 
* Человека с Именем Клеопатра и ростом 152 
* Человека с Именем Пушкин Александр Сергеевичи ростом 167 
* Человека с Именем Маяковский Владимир и ростом 189 
* ### Человек с родителем

Измените сущность Человек из задачи 2.2 добавив ему возможность задавать третий параметр: 
Отец, где Отец — это тоже Человек. При приведении человека к строковой форме необходимо 
проверить параметры имени, и в зависимости от ситуации выполнить одно из следующих 
действий: 
* Если у данного человека нет фамилии, и есть отец, у которого фамилия задана, то 
фамилию необходимо сделать такой же как у отца. 
* Если у данного человека нет отчества, а у отца есть имя, то необходимо задать отчество 
как имя отца с добавлением суффикса “ович”.  
Затем необходимо выполнить следующие задачи: 
1. Создать людей: Чудова Ивана, Чудова Петра, Бориса 
2. Сделать Ивана отцом Петра, а Петра отцом Бориса 
3. Вывести на экран строковое представление всех троих людей.
* ### Города

Создайте сущность Город, которая будет представлять собой точку на карте со следующими 
характеристиками: 
* Название города 
* Набор путей к следующим городам, где путь представляет собой сочетание Города и 
стоимости поездки в него.

Кроме того, Город может возвращать текстовое представление, в виде названия города и списка 
связанных с ним городов (в виде пары: “название:стоимость”). 
Используя разработанную сущность реализуйте схему, представленную на рисунке 2.
* ### Создаем Имена

Измените сущность Имя из задачи 1.3. Новые требования включают: 
* Имя можно создать указав только Личное имя 
* Имя можно создать указав  Личное имя и Фамилию. 
* Имя можно создать указав все три параметра: Личное имя, Фамилию, Отчество. 
Необходимо создать следующие имена: 
1. Клеопатра 
2. Александр Сергеевич Пушкин 
3. Владимир Маяковский 
4. Христофор Бонифатьевич (здесь Христофор это имя, а Бонифатьевич - фамилия)
* ### Создаем человека

Измените сущность Человек из задачи 2.3. Новые требования включают: 
* Человека можно создать с указанием имени в виде строки и роста в виде целого числа. 
При таком способе задания имени должно считаться, что Человеку задано только личное 
имя. 
* Человека можно создать с указанием имени в виде строки, роста в виде целого числа и 
отца в виде Человека. В этом случае необходимо проставить отчество в соответствии с 
именем отца и присвоить текущему человеку фамилию отца. 
* Человека можно создать с указанием имени в виде объекта типа Имя (из задачи 4.5) и 
роста в виде целого числа.  
* Человека можно создать с указанием имени в виде объекта типа Имя (из задачи 4.5), 
роста в виде целого числаи отца в виде Человека. В этом случае необходимо проверить 
что в Имени задано отчество и фамилия, и если они не заданы, то необходимо их задать 
(отчество в соответствии с именем отца и фамилию отца). 
* Реализуйте описанные способы создания Человека таким образом, чтобы операции 
присвоения использовались только в одном из конструкторов.  
* Необходимо модифицировать способ приведения Человека к строке, теперь текстовая 
форма должна быть представлена строкой: “Имя, рост” 
Создайте и выведите на экран следующие объекты: 
1. Человека с именем Лев (в виде строки) и ростом 170 
2. Человека с именем Пушкин Сергей (как Имя), ростом 168 и отцом Львом (предыдущий Человек) 
3. Человека с именем Александр (в виде строки), ростом 167 и отцом Сергеем (предыдущий 
Человек)
* ### Кот мяукает

Создайте сущность Кот, которая описывается следующим образом: 
* Имеет Имя (строка) 
* Для создания необходимо указать имя кота. 
* Может быть приведен к текстовой форме вида: “кот: Имя” 
* Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, 
вызвать мяуканье можно без параметров. 
* Может помяукать Nраз, что приводит к выводу на экран следующего текста: “Имя: мяу
мяу-…-мяу!”, где количество “мяу”равно N. 
Создайте кота по имени “Барсик”, и затем пусть он помяукает сначала один раз, а затем три раза.

### Задачи лабораторной работы 3:
* ### Непустые Имена

Измените сущность Имя из задачи 1.4.5. Гарантируйте, что: 
* Как минимум один параметр будет иметь не null значение и не пустую строку. 
* Имя неизменяемо. 
Продемонстрируйте работоспособность решения на примерах.
* ### Человек меняется

Измените сущность Человек из задачи 1.4.6. Новые требования включают: 
* Рост человека всегда положительный и не более 500, его можно изменить и получить в 
любой момент. 
* Отца возможно задать только при создании и в дальнейшем он не изменяется, но его 
можно получить 
* Имя можно получить в любой момент в виде объекта типа Имя.  
Продемонстрируйте работоспособность решения на примерах.
* ### Секреты

Секреты никому нельзя рассказывать. Никому кроме одного самого близкого друга! Необходимо 
описать сущность Секрет, которая будет позволять хранить и передавать некоторый текст только 
одному другому хранителю. 
Состояние сущности описывают следующие сведения:  
* Текст секрета, в виде строки. 
* Имя хранителя секрета, в виде строки 
Инициализация сущности может быть выполнена следующим образом: 
* С указанием имени хранителя секрета и текста секрета, это будет означать создание 
нового секрета. 
* С указанием другого Секрета и именем хранителя секрета. В этом случае мы считаем, что 
секрет был рассказан другому человеку. При передаче секрета должно произойти 
следующее: во-первых, на консоль выводится текст вида “Имя сказал что Секрет”, где Имя 
и Секрет представляют собой имя того кто рассказывает секрет и текст секрета 
соответственно. Во-вторых, текст секрета у нового хранителя должен представлять собой 
копию текста предыдущего хранителя, но с добавлением Х случайных символов в Х 
случайных мест, где Х — это число в диапазоне от 0 до N, а Nв свою очередь это 10% от 
размера исходного текста. 
Поведение сущности описывают следующие действия: 
* Может быть приведен к строке, строковое преставление вида“Имя: это секрет!”, где Имя – 
это конкретное имя хранителя секрета, а остальное простой текст. 
* Можно узнать каким по очереди был данных хранитель секрета. 
* Можно узнать сколько еще человек узнали секрет после текущего хранителя 
* Можно получить имя N-го человек узнавшего секрет, причем N будет положительным для 
случая, когда мы хотим узнать имя следующего узнавшего секрет, и отрицательным если 
предыдущего. 
* Можно узнать разницу в количестве символов текста секрета с N-ым человеком 
Необходимо учесть следующие требования к инкапсуляции: 
* Единственным способом получить текст секрета может быт его вывод на экран при 
инициализации объекта. 
* Секрет может быть передан только одному другому человеку и не должно быть способа 
рассказать один и тот же секрет нескольким людям. 
Продемонстрируйте работоспособность решения на примерах.
* ### Трехмерная точка

Создайте такой подвид сущности Точка из задачи 1.1.1, которая будет иметь не две, а три 
координаты на плоскости: X,Y,Z.
* ### Птицы

Создайте сущность Птица, которая будет являться корнем иерархии для всех, кто является 
подвидом птицы. В разработанную сущность необходимо вынести все, что будет общим для птиц. 
Для того чтобы определить необходимые члены класса, проанализируйте три примера птиц: 
* Воробей. Умеет петь. При пении на экран выводится строка “чырык”. 
* Кукушка. Умеет петь. При пении на экран выводится текст“ку-ку”, причем текст 
выводится случайное количество раз в диапазоне от 1 до 10. 
* Попугай. Имеет текст и умеет петь этот текст. При инициализации обязательно 
необходимо указать текст, который будет исполняться. При пении текст выводится не 
весь, а первые Nсимволов (не менее одного и не более всех символов текста), где N 
определяется случайно.
* ### Мяуканье

Разработайте метод, который принимает набор объектов способных мяукать и вызывает 
мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со следующей 
сигнатурой: 
public void meow(); 
Дополните решение задачи 1.5.2(Кот) так, чтобы иметь возможность передать Кота в 
написанный вами метод и протестируйте работоспособность решения передав в него нескольких 
котов, а также создайте любой другой произвольный класс и передайте в написанный метод его 
объекты. 
* ### Сравнение точек 

Измените сущность Точка из задачи 1.4.1. Переопределите метод сравнения объектов по 
состоянию таким образом, чтобы две точки считались одинаковыми тогда, когда они 
расположены в одинаковых координатах.
* ### Навести порядок
    
Данная задача предполагает реорганизацию ранее написанных классов. Расположите все ранее 
написанные классы по пакетам таким образом, чтобы логически близкие классы оказались 
сгруппированы друг с другом. Имена пакетов должны иметь как минимум трехсоставную форму, 
вида: ru.surname.type. Вместо surname следует подставить свою фамилию, а вместо type 
подставить название логического блока. Например, классы описывающие точку, линию, ломаную 
линию, фигуру, квадрат, треугольник, круг и прямоугольник можно расположить в пакете 
ru.surname.geometry.  
* ### Главный метод

Создайте пакет ru.surname.main (вместо surname необходимо подставить собственную 
фамилию) в котором расположить класс с точкой входа в исполнение программы (public static void 
main). Также следует проверить, что ни в одном другом пакете нет классов имеющих точку входа 
в исполнение программы. В этом же пакете необходимо расположить класс (или интерфейс) с 
методами из задач блока 2.5 и продемонстрировать их работоспособность.  
* ### Возведение в степень

Создайте метод принимающий две строки, в которых будут записаны числа X и Y. Возвращает 
метод результат возведения X в степень Y. Для преобразования строки в число следует 
использовать метод Integer.parseInt, а для возведения в степень метод Math.pow. Вызовите 
разработанный метод передав туда параметры командной строки полученные точкой входа в 
программу. Реализуйте метод так, что бы для возведения в степень и преобразования строки 
использовались короткие имена статических методов.
* ### Клонирование точки  

Измените сущность Точка из 3.6.2.Переопределите метод клонирования, унаследованный от 
класса Object, таким образом, чтобы при его вызове возвращался новый объект Точки, значения 
полей которого будут копиями оригинальной Точки.

### Задачи лабораторной работы 4:
* ### Обобщенная коробка.
 
Создайте сущность Коробка, которая обладает следующими характеристиками: 
* Может хранить один произвольный объект в один момент времени. 
* Объект можно получить и разместить на хранение в любой момент времени. 
* Если объект забирают из коробки – ссылку на этот объект необходимо обнулить. 
* Если объект кладут в коробку, но она не пуста – необходимо выкинуть исключение. 
* Имеет метод проверки на заполненность. 
* Методы класса должны работать с тем типом данных, который был указан во время 
создания объекта 
Создайте Коробку которая может хранить целочисленное значение, разместите туда число 3. 
Передайте Коробку в какой-либо метод, извлеките значение, и выведите его на экран.

 Решение
 1. Создать класс box<T> и базовые set и get функции, а также конструкторы.
 2. Добавить функцию "распаковки" содержимого
 3. Добавить функцию putInside, которая может выкинуть исключение если что то уже внутри.


* ### Без null.

Создайте сущность Хранилище, которая обладает следующими характеристиками: 
* Может хранить один произвольный объект в один момент времени. 
* Хранилище неизменяемо. 
* Объект кладется в Хранилище при его создании. В качестве объекта может быть 
сохранено также и значение null. 
* Хранилище может вернуть ссылку на Объект. 
* Если вместо объекта хранится null, необходимо вернуть какое-либо альтернативное 
значение. 
* Метод получения значения должен работать с тем типом данных, который был указан во 
время создания объекта 
Выполните следующие задания: 
* Создайте Хранилище чисел, положите туда значение null. Передайте Хранилище в какой
либо метод, извлеките значение, и выведите его на экран. Альтернативой должно быть 
число 0. 
* Создайте Хранилище чисел, положите туда значение 99. Передайте Хранилище в какой
либо метод, извлеките значение, и выведите его на экран. Альтернативой должно быть 
число -1. 
* Создайте Хранилище строк, положите туда значение null. Передайте Хранилище в какой
либо метод, извлеките значение, и выведите его на экран. Альтернативой должна быть 
строка “default”. 
* Создайте Хранилище строк, положите туда значение “hello”. Передайте Хранилище в 
какой-либо метод, извлеките значение, и выведите его на экран. Альтернативой должна 
быть строка “hello world”.

Решение
 1. Создать класс vault<T> и базовые set и get функции, а также конструкторы.
 2. Добавить альтернативное содержимое T alt, функцию для редактирования альтернативного содержимого и его просмотра.
 3. Добавить функцию putInside, которая может выкинуть исключение если что то уже внутри.

* ### Начало отсчета. 

Создайте метод, принимающий Коробку из задачи 3.1.1, и кладет в неё трехмерную точку 
координат (из задачи 2.1.5) с произвольными значениями. Метод должен позволять передавать 
Коробку с более чем одним видом параметризации.

Решение
 1. Положить внутрь коробки обьект класса dot.

* ### Функция.  

Разработайте такой метод, который будет принимать список значений типа T, и объект имеющий 
единственный метод apply. Данный метод надо применить к каждому элементу списка, и вернуть 
новый список значений типа P, при этом типы T и P могут совпадать, а могут не совпадать. 
Используйте разработанный метод следующим образом: 
1. Передайте в метод список со значениями:“qwerty”, “asdfg”, “zx”, а получите список чисел, 
где каждое число соответствует длине каждой строки. 
2. Передайте в метод список со значениями: 1,-3,7, а получите список в котором все 
отрицательные числа стали положительными, а положительные остались без изменений 
3. Передайте в метод список состоящий из массивов целых чисел, а получите список в 
котором будут только максимальные значения каждого из исходных массивов

Решение
 1. Создать интерфейс, имеющий метод apply.
 2. Создать класс, содержащий функцию имеющую в параметрах обьект интерфейса.
 3. Внутри функции установить, что apply применяется для каждого элемента списка.
 4. В main функции вернуть необходимые величины для каждого типа передаваемых данных.

* ### Фильтр.
Разработайте такой метод, который будет принимать список значений типа T и объект имеющий
единственный метод test (принимает T и возвращает boolean). Верните новый список типа T, из
которого удалены все значения не прошедшие проверку условием.
Используйте разработанный метод следующим образом:
* Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и отфильтруйте все
строки имеющие менее трех символов
* Передайте в метод список со значениями: 1,-3,7, и отфильтруйте все положительные
элементы
* Передайте в метод список состоящий из массивов целых чисел, а получите список в
котором будут только те массивы, в которых нет ни одного положительного элемент

Решение
 1. Создать интерфейс, имеющий метод test.
 2. Создать класс, содержащий функцию имеющую в параметрах обьект интерфейса.
 3. Внутри функции установить, что test применяется для каждого элемента списка.
 4. В main функции вернуть необходимые условия фильтрации для каждого типа передаваемых данных.

* ### Сокращение.
Разработайте такой метод, который будет принимать список значений типа T и способ с помощью
которого список значений можно свести к одному значению типа T, которое и возвращается из
метода.
Используйте разработанный метод следующим образом:
* Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и сформируйте одну
большую строку, которая состоит из всех строк исходного списка.
* Передайте в метод список со значениями: 1,-3,7, и верните сумму всех значений исходного
списка.
* Имеется список, состоящий из списков целых чисел, получите общеe количество
элементов во всех списках. Подсказка: решить задачу можно в одно действие или
последовательно использовать методы из 3.3.1 и 3.3.3.
Далее необходимо изменить разработанный метод таким образом, чтобы данный метод
гарантированно не возвращал null и не выбрасывал ошибок в том случае, если исходный список
пуст.


Решение
 1. Создать интерфейс, имеющий метод apply.
 2. Создать класс, содержащий функцию имеющую в параметрах обьект интерфейса.
 3. Создать дополнительную проверку null значений.
 4. Внутри функции установить, что apply применяется для каждого элемента списка.
 5. В main функции вернуть необходимые условия для каждого типа передаваемых данных.

### Задачи лабораторной работы 5:
* ### Шаблоны
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка 
числителя и установка знаменателя. 
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного 
значения. 
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими 
особенностями: 
* Имеет числитель: целое число 
* Имеет знаменатель: целое число 
* Дробь может быть создана с указанием числителя и знаменателя  
* Может вернуть строковое представление вида “числитель/знаменатель” 
* Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может 
быть отрицательным.  
* Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби 
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя. 

* ### Количество мяуканий
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4. 
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы 
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом 
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим 
количество мяуканий на экран. Кота изменять нельзя. 
 
Если раннее в вашем варианте не было Кота, то создайте  
1. сущность Кот, которая описывается следующим образом: 
* Имеет Имя (строка) 
* Для создания необходимо указать имя кота. 
* Может быть приведен к текстовой форме вида: “кот: Имя” 
* Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, 
вызвать мяуканье можно без параметров. 
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных 
мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со 
следующей сигнатурой: 
public void meow();

* ### Список
Составить программу, которая в списке L из каждой группы подряд идущих одинаковых 
элементов оставляет только один. 

* ### Мап
В молочных магазинах города Х продается сметана с жирностью 15, 20 и 25 процентов. В городе 
X был проведен мониторинг цен на сметану. Напишите эффективную по времени работы и по 
используемой памяти программу, которая будет определять для каждого вида сметаны, сколько 
магазинов продают ее дешевле всего. На вход программе сначала подается число магазинов N. В 
каждой из следующих N строк находится информация в следующем формате: 
<Фирма><Улица><Жирность><Цена> 
где <Фирма> – строка, состоящая не более, чем из 20 символов без пробелов, <Улица> – строка, 
состоящая не более, чем из 20 символов без пробелов, <Жирность> – одно из чисел – 15, 20 или 
25, <Цена> – целое число в диапазоне от 2000 до 5000, обозначающее стоимость одного литра 
сметаны в копейках. <Фирма> и <Улица>,<Улица> и <Жирность>, а также <Жирность> и <Цена> 
разделены ровно одним пробелом. Пример входной строки: 
Перекресток Короленко 25 120 
Программа должна выводить через пробел 3 числа – количество магазинов, продающих дешевле 
всего сметану с жирностью 15, 20 и 25 процентов. Если какой-то вид сметаны нигде не 
продавался, то следует вывести 0. 
Пример выходных данных: 
12 10 0 

* ### Сет
Файл содержит текст на русском языке. Какие цифры встречаются в тексте?

* ### Очередь
Определить, есть ли в очереди L хотя бы один элемент, который равен следующему за ним (по 
кругу) элементу (первый элемент считать следующим для последнего). 

* ### Стрим 1
Необходимо написать стрим: 
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с 
одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это 
все в ломаную (объект типа Polyline) 
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их: 
1. класс Point: 
* Координата Х: число.   
* Координата Y: число. 
* Может возвращать текстовое представление вида “{X;Y}”. 
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается: 
* Координата начала: Точка 
* Координата конца: Точка 
* Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}” 
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная 
линия представляет собой набор следующих характеристик:   
* Имеет массив Точек, через которые линия проходит. 
* Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это 
результат приведения к строке Точки с номером N

* ### Стрим 2

Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме: 
Вася:5 
Петя:3 
Аня:5 
Номера людей могут повторяться. У каких-то людей может не быть номера. 
Необходимо написать стрим выполняющую следующее: 
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в 
верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются 
по их номеру: 
[5:[Вася, Аня], 3:[Петя]]

### Задачи лабораторной работы 6:
* ### @Invoke.

Разработайте аннотацию @Invoke, со следующими характеристиками: 
• Целью может быть только МЕТОД 
• Доступна во время исполнения программы 
• Не имеет свойств 
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них 
аннотацией @Invoke. 
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные 
аннотацией @Invoke, и вызывает их автоматически. 

* ### @Default.

Разработайте аннотацию @Default, со следующими характеристиками: 
• Целью может быть ТИП или ПОЛЕ 
• Доступна во время исполнения программы 
• Имеет обязательное свойство value типа Class 
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию. 
Напишите обработчик, который выводит имя указанного класса по умолчанию.

* ### @ToString.

Разработайте аннотацию @ToString, со следующими характеристиками: 
• Целью может быть ТИП или ПОЛЕ 
• Доступна во время исполнения программы 
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO 
• Значение свойства по умолчанию: YES 
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO). 
Создайте метод, который формирует строковое представление объекта, учитывая только те поля, 
где @ToString имеет значение YES. 

* ### @Validate.

Разработайте аннотацию @Validate, со следующими характеристиками: 
• Целью может быть ТИП или АННОТАЦИЯ 
• Доступна во время исполнения программы 
• Имеет обязательное свойство value, типа Class[] 
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки. 
Реализуйте обработчик, который выводит, какие классы указаны в аннотации. 

* ### @Two.

Разработайте аннотацию @Two, со следующими характеристиками: 
• Целью может быть ТИП 
• Доступна во время исполнения программы 
• Имеет два обязательных свойства: first типа String и second типа int 
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения. 
Реализуйте обработчик, который считывает и выводит значения этих свойств. 

* ### @Cache.  

Разработайте аннотацию @Cache, со следующими характеристиками: 
• Целью может быть ТИП 
• Доступна во время исполнения программы 
• Имеет необязательное свойство value, типа String[] 
• Значение свойства по умолчанию: пустой массив 
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей. 
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что 
список пуст. 

## Тесты
![alt text](README_data/Birds_3.png)
![alt text](README_data/Cat_2.png)
![alt text](README_data/Cat_3.png)
![alt text](README_data/City_2.png)
![alt text](README_data/Dot_3.png)
![alt text](README_data/Secret_3.png)
![alt text](README_data/Human_3.png)

## To do
- [x] Лабораторная работа 1
- [x] Лабораторная работа 2
- [x] Лабораторная работа 3
- [x] Лабораторная работа 4
- [x] Лабораторная работа 5
- [ ] Лабораторная работа 6

 ## Команда проекта
 Завьялов Артур/Serr410
 Группа ИТ-11
***
